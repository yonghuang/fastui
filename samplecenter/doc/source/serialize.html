<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">///import core
///commands 定制过滤规则
///commandsName  Serialize
///commandsTitle  定制过滤规则
UE.plugins['serialize'] = function () {
    var ie = browser.ie,
        version = browser.version;

    function ptToPx(value){
        return /pt/.test(value) ? value.replace( /([\d.]+)pt/g, function( str ) {
            return  Math.round(parseFloat(str) * 96 / 72) + &quot;px&quot;;
        } ) : value;
    }
    var me = this,
            EMPTY_TAG = dtd.$empty,
            parseHTML = function () {
                 //干掉&lt;a&gt; 后便变得空格，保留&lt;/a&gt;  这样的空格
                var RE_PART = /&lt;(?:(?:\/([^&gt;]+)&gt;)|(?:!--([\S|\s]*?)--&gt;)|(?:([^\s\/&gt;]+)\s*((?:(?:&quot;[^&quot;]*&quot;)|(?:'[^']*')|[^&quot;'&lt;&gt;])*)\/?&gt;))/g,
                        RE_ATTR = /([\w\-:.]+)(?:(?:\s*=\s*(?:(?:&quot;([^&quot;]*)&quot;)|(?:'([^']*)')|([^\s&gt;]+)))|(?=\s|$))/g,
                                        EMPTY_ATTR = {checked:1,compact:1,declare:1,defer:1,disabled:1,ismap:1,multiple:1,nohref:1,noresize:1,noshade:1,nowrap:1,readonly:1,selected:1},
                                        CDATA_TAG = {script:1,style: 1},
                                        NEED_PARENT_TAG = {
                                            &quot;li&quot;: { &quot;$&quot;: 'ul', &quot;ul&quot;: 1, &quot;ol&quot;: 1 },
                                            &quot;dd&quot;: { &quot;$&quot;: &quot;dl&quot;, &quot;dl&quot;: 1 },
                                            &quot;dt&quot;: { &quot;$&quot;: &quot;dl&quot;, &quot;dl&quot;: 1 },
                                            &quot;option&quot;: { &quot;$&quot;: &quot;select&quot;, &quot;select&quot;: 1 },
                                            &quot;td&quot;: { &quot;$&quot;: &quot;tr&quot;, &quot;tr&quot;: 1 },
                                            &quot;th&quot;: { &quot;$&quot;: &quot;tr&quot;, &quot;tr&quot;: 1 },
                                            &quot;tr&quot;: { &quot;$&quot;: &quot;tbody&quot;, &quot;tbody&quot;: 1, &quot;thead&quot;: 1, &quot;tfoot&quot;: 1, &quot;table&quot;: 1 },
                                            &quot;tbody&quot;: { &quot;$&quot;: &quot;table&quot;, 'table':1,&quot;colgroup&quot;: 1 },
                                            &quot;thead&quot;: { &quot;$&quot;: &quot;table&quot;, &quot;table&quot;: 1 },
                                            &quot;tfoot&quot;: { &quot;$&quot;: &quot;table&quot;, &quot;table&quot;: 1 },
                                            &quot;col&quot;: { &quot;$&quot;: &quot;colgroup&quot;,&quot;colgroup&quot;:1 }
                                        };
                                var NEED_CHILD_TAG = {
                    &quot;table&quot;: &quot;td&quot;, &quot;tbody&quot;: &quot;td&quot;, &quot;thead&quot;: &quot;td&quot;, &quot;tfoot&quot;: &quot;td&quot;, &quot;tr&quot;: &quot;td&quot;,
                    &quot;colgroup&quot;: &quot;col&quot;,
                    &quot;ul&quot;: &quot;li&quot;, &quot;ol&quot;: &quot;li&quot;,
                    &quot;dl&quot;: &quot;dd&quot;,
                    &quot;select&quot;: &quot;option&quot;
                };

                function parse( html, callbacks ) {

                    var match,
                            nextIndex = 0,
                            tagName,
                            cdata;
                    RE_PART.exec( &quot;&quot; );
                    while ( (match = RE_PART.exec( html )) ) {

                        var tagIndex = match.index;
                        if ( tagIndex &gt; nextIndex ) {
                            var text = html.slice( nextIndex, tagIndex );
                            if ( cdata ) {
                                cdata.push( text );
                            } else {
                                callbacks.onText( text );
                            }
                        }
                        nextIndex = RE_PART.lastIndex;
                        if ( (tagName = match[1]) ) {
                            tagName = tagName.toLowerCase();
                            if ( cdata &amp;&amp; tagName == cdata._tag_name ) {
                                callbacks.onCDATA( cdata.join( '' ) );
                                cdata = null;
                            }
                            if ( !cdata ) {
                                callbacks.onTagClose( tagName );
                                continue;
                            }
                        }
                        if ( cdata ) {
                            cdata.push( match[0] );
                            continue;
                        }
                        if ( (tagName = match[3]) ) {
                            if ( /=&quot;/.test( tagName ) ) {
                                continue;
                            }
                            tagName = tagName.toLowerCase();
                            var attrPart = match[4],
                                    attrMatch,
                                    attrMap = {},
                                    selfClosing = attrPart &amp;&amp; attrPart.slice( -1 ) == '/';
                            if ( attrPart ) {
                                RE_ATTR.exec( &quot;&quot; );
                                while ( (attrMatch = RE_ATTR.exec( attrPart )) ) {
                                    var attrName = attrMatch[1].toLowerCase(),
                                            attrValue = attrMatch[2] || attrMatch[3] || attrMatch[4] || '';
                                    if ( !attrValue &amp;&amp; EMPTY_ATTR[attrName] ) {
                                        attrValue = attrName;
                                    }
                                    if ( attrName == 'style' ) {
                                        if ( ie &amp;&amp; version &lt;= 6 ) {
                                            attrValue = attrValue.replace( /(?!;)\s*([\w-]+):/g, function ( m, p1 ) {
                                                return p1.toLowerCase() + ':';
                                            } );
                                        }
                                    }
                                    //没有值的属性不添加
                                    if ( attrValue ) {
                                        attrMap[attrName] = attrValue.replace( /:\s*/g, ':' )
                                    }

                                }
                            }
                            callbacks.onTagOpen( tagName, attrMap, selfClosing );
                            if ( !cdata &amp;&amp; CDATA_TAG[tagName] ) {
                                cdata = [];
                                cdata._tag_name = tagName;
                            }
                            continue;
                        }
                        if ( (tagName = match[2]) ) {
                            callbacks.onComment( tagName );
                        }
                    }
                    if ( html.length &gt; nextIndex ) {
                        callbacks.onText( html.slice( nextIndex, html.length ) );
                    }
                }

                return function ( html, forceDtd ) {

                    var fragment = {
                        type: 'fragment',
                        parent: null,
                        children: []
                    };
                    var currentNode = fragment;

                    function addChild( node ) {
                        node.parent = currentNode;
                        currentNode.children.push( node );
                    }

                    function addElement( element, open ) {
                        var node = element;
                        // 遇到结构化标签的时候
                        if ( NEED_PARENT_TAG[node.tag] ) {
                            // 考虑这种情况的时候, 结束之前的标签
                            // e.g. &lt;table&gt;&lt;tr&gt;&lt;td&gt;12312`&lt;tr&gt;`4566
                            while ( NEED_PARENT_TAG[currentNode.tag] &amp;&amp; NEED_PARENT_TAG[currentNode.tag][node.tag] ) {
                                currentNode = currentNode.parent;
                            }
                            // 如果前一个标签和这个标签是同一级, 结束之前的标签
                            // e.g. &lt;ul&gt;&lt;li&gt;123&lt;li&gt;
                            if ( currentNode.tag == node.tag ) {
                                currentNode = currentNode.parent;
                            }
                            // 向上补齐父标签
                            while ( NEED_PARENT_TAG[node.tag] ) {
                                if ( NEED_PARENT_TAG[node.tag][currentNode.tag] ) break;
                                node = node.parent = {
                                    type: 'element',
                                    tag: NEED_PARENT_TAG[node.tag]['$'],
                                    attributes: {},
                                    children: [node]
                                };
                            }
                        }
                        if ( forceDtd ) {

                            // 如果遇到这个标签不能放在前一个标签内部，则结束前一个标签,span单独处理
                            while ( dtd[node.tag] &amp;&amp; !(currentNode.tag == 'span' ? utils.extend( dtd['strong'], {'a':1,'A':1} ) : (dtd[currentNode.tag] || dtd['div']))[node.tag] ) {
                                if ( tagEnd( currentNode ) ) continue;
                                if ( !currentNode.parent ) break;
                                currentNode = currentNode.parent;
                            }
                        }
                        node.parent = currentNode;
                        currentNode.children.push( node );
                        if ( open ) {
                            currentNode = element;
                        }
                        if ( element.attributes.style ) {
                            element.attributes.style = element.attributes.style.toLowerCase();
                        }
                        return element;
                    }

                    // 结束一个标签的时候，需要判断一下它是否缺少子标签
                    // e.g. &lt;table&gt;&lt;/table&gt;
                    function tagEnd( node ) {
                        var needTag;
                        if ( !node.children.length &amp;&amp; (needTag = NEED_CHILD_TAG[node.tag]) ) {
                            addElement( {
                                type: 'element',
                                tag: needTag,
                                attributes: {},
                                children: []
                            }, true );
                            return true;
                        }
                        return false;
                    }

                    parse( html, {
                        onText: function ( text ) {

                            while ( !(dtd[currentNode.tag] || dtd['div'])['#'] ) {
                                //节点之间的空白不能当作节点处理
//                                if(/^[ \t\r\n]+$/.test( text )){
//                                    return;
//                                }
                                if ( tagEnd( currentNode ) ) continue;
                                currentNode = currentNode.parent;
                            }
                            //if(/^[ \t\n\r]*/.test(text))
                                addChild( {
                                    type: 'text',
                                    data: text
                                } );

                        },
                        onComment: function ( text ) {
                            addChild( {
                                type: 'comment',
                                data: text
                            } );
                        },
                        onCDATA: function ( text ) {
                            while ( !(dtd[currentNode.tag] || dtd['div'])['#'] ) {
                                if ( tagEnd( currentNode ) ) continue;
                                currentNode = currentNode.parent;
                            }
                            addChild( {
                                type: 'cdata',
                                data: text
                            } );
                        },
                        onTagOpen: function ( tag, attrs, closed ) {
                            closed = closed || EMPTY_TAG[tag] ;
                            addElement( {
                                type: 'element',
                                tag: tag,
                                attributes: attrs,
                                closed: closed,
                                children: []
                            }, !closed );
                        },
                        onTagClose: function ( tag ) {
                            var node = currentNode;
                            // 向上找匹配的标签, 这里不考虑dtd的情况是因为tagOpen的时候已经处理过了, 这里不会遇到
                            while ( node &amp;&amp; tag != node.tag ) {
                                node = node.parent;
                            }
                            if ( node ) {
                                // 关闭中间的标签
                                for ( var tnode = currentNode; tnode !== node.parent; tnode = tnode.parent ) {
                                    tagEnd( tnode );
                                }
                                //去掉空白的inline节点
                                //分页，锚点保留
                                //|| dtd.$removeEmptyBlock[node.tag])
//                                if ( !node.children.length &amp;&amp; dtd.$removeEmpty[node.tag] &amp;&amp; !node.attributes.anchorname &amp;&amp; node.attributes['class'] != 'pagebreak' &amp;&amp; node.tag != 'a') {
//
//                                    node.parent.children.pop();
//                                }
                                currentNode = node.parent;
                            } else {
                                // 如果没有找到开始标签, 则创建新标签
                                // eg. &lt;/div&gt; =&gt; &lt;div&gt;&lt;/div&gt;
                                //针对视屏网站embed会给结束符，这里特殊处理一下
                                if ( !(dtd.$removeEmpty[tag] || dtd.$removeEmptyBlock[tag] || tag == 'embed') ) {
                                    node = {
                                        type: 'element',
                                        tag: tag,
                                        attributes: {},
                                        children: []
                                    };
                                    addElement( node, true );
                                    tagEnd( node );
                                    currentNode = node.parent;
                                }


                            }
                        }
                    } );
                    // 处理这种情况, 只有开始标签没有结束标签的情况, 需要关闭开始标签
                    // eg. &lt;table&gt;
                    while ( currentNode !== fragment ) {
                        tagEnd( currentNode );
                        currentNode = currentNode.parent;
                    }
                    return fragment;
                };
            }();
    var unhtml1 = function () {
        var map = { '&lt;': '&amp;lt;', '&gt;': '&amp;gt;', '&quot;': '&amp;quot;', &quot;'&quot;: '&amp;#39;' };

        function rep( m ) {
            return map[m];
        }

        return function ( str ) {
            str = str + '';
            return str ? str.replace( /[&lt;&gt;&quot;']/g, rep ) : '';
        };
    }();
    var toHTML = function () {
        function printChildren( node, pasteplain ) {
            var children = node.children;

            var buff = [];
            for ( var i = 0,ci; ci = children[i]; i++ ) {

                buff.push( toHTML( ci, pasteplain ) );
            }
            return buff.join( '' );
        }

        function printAttrs( attrs ) {
            var buff = [];
            for ( var k in attrs ) {
                var value = attrs[k];
                
                if(k == 'style'){

                    //pt==&gt;px
                    value = ptToPx(value);
                    //color rgb ==&gt; hex
                    if(/rgba?\s*\([^)]*\)/.test(value)){
                        value = value.replace( /rgba?\s*\(([^)]*)\)/g, function( str ) {
                            return utils.fixColor('color',str);
                        } )
                    }
                    attrs[k] = utils.optCss(value.replace(/windowtext/g,'#000'));
                }

                buff.push( k + '=&quot;' + unhtml1( attrs[k] ) + '&quot;' );
            }
            return buff.join( ' ' )
        }

        function printData( node, notTrans ) {
            //trace:1399 输入html代码时空格转换成为&amp;nbsp;
            //node.data.replace(/&amp;nbsp;/g,' ') 针对pre中的空格和出现的&amp;nbsp;把他们在得到的html代码中都转换成为空格，为了在源码模式下显示为空格而不是&amp;nbsp;
            return notTrans ? node.data.replace(/&amp;nbsp;/g,' ') : unhtml1( node.data ).replace(/ /g,'&amp;nbsp;');
        }

        //纯文本模式下标签转换
        var transHtml = {
            'div':'p',
            'li':'p',
            'tr':'p',
            'br':'br',
            'p':'p'//trace:1398 碰到p标签自己要加上p,否则transHtml[tag]是undefined

        };

        function printElement( node, pasteplain ) {
            var tag = node.tag;
            if ( pasteplain &amp;&amp; tag == 'td' ) {
                if ( !html ) html = '';
                html += printChildren( node, pasteplain ) + '&amp;nbsp;&amp;nbsp;&amp;nbsp;';
            } else {
                var attrs = printAttrs( node.attributes );
                var html = '&lt;' + (pasteplain &amp;&amp; transHtml[tag] ? transHtml[tag] : tag) + (attrs ? ' ' + attrs : '') + (EMPTY_TAG[tag] ? ' /&gt;' : '&gt;');
                if ( !EMPTY_TAG[tag] ) {
                    //trace:1627
                    //p标签在ie下为空，将不占位这里占位符不起作用，用&amp;nbsp;
                    if(browser.ie &amp;&amp; tag == 'p' &amp;&amp; !node.children.length){
                        html += '&amp;nbsp;';
                    }
                    html += printChildren( node, pasteplain );
                    html += '&lt;/' + (pasteplain &amp;&amp; transHtml[tag] ? transHtml[tag] : tag) + '&gt;';
                }
            }

            return html;
        }

        return function ( node, pasteplain ) {
            if ( node.type == 'fragment' ) {
                return printChildren( node, pasteplain );
            } else if ( node.type == 'element' ) {
                return printElement( node, pasteplain );
            } else if ( node.type == 'text' || node.type == 'cdata' ) {
                return printData( node, dtd.$notTransContent[node.parent.tag] );
            } else if ( node.type == 'comment' ) {
                return '&lt;!--' + node.data + '--&gt;';
            }
            return '';
        };
    }();

    //过滤word
    var transformWordHtml = function () {

        function isWordDocument( strValue ) {
            var re = new RegExp( /(class=&quot;?Mso|style=&quot;[^&quot;]*\bmso\-|w:WordDocument|&lt;v:)/ig );
            return re.test( strValue );
        }

        function ensureUnits( v ) {
            v = v.replace( /([\d.]+)([\w]+)?/g, function ( m, p1, p2 ) {
                return (Math.round( parseFloat( p1 ) ) || 1) + (p2 || 'px');
            } );
            return v;
        }

        function filterPasteWord( str ) {
            str = str.replace( /&lt;!--\s*EndFragment\s*--&gt;[\s\S]*$/, '' )
                //remove link break
                .replace( /^(\r\n|\n|\r)|(\r\n|\n|\r)$/ig, &quot;&quot; )
                //remove &amp;nbsp; entities at the start of contents
                .replace( /^\s*(&amp;nbsp;)+/ig, &quot;&quot; )
                //remove &amp;nbsp; entities at the end of contents
                .replace( /(&amp;nbsp;|&lt;br[^&gt;]*&gt;)+\s*$/ig, &quot;&quot; )
                // Word comments like conditional comments etc
                .replace( /&lt;!--[\s\S]*?--&gt;/ig, &quot;&quot; )
                //转换图片
                .replace(/&lt;v:shape [^&gt;]*&gt;[\s\S]*?.&lt;\/v:shape&gt;/gi,function(str){
                    var width = str.match(/width:([ \d.]*p[tx])/i)[1],
                        height = str.match(/height:([ \d.]*p[tx])/i)[1],
                        src =  str.match(/src=\s*&quot;([^&quot;]*)&quot;/i)[1];
                    return '&lt;img width=&quot;'+ptToPx(width)+'&quot; height=&quot;'+ptToPx(height)+'&quot; src=&quot;' + src + '&quot; /&gt;'
                })
                //去掉多余的属性
                .replace( /v:\w+=[&quot;']?[^'&quot;]+[&quot;']?/g, '' )
                // Remove comments, scripts (e.g., msoShowComment), XML tag, VML content, MS Office namespaced tags, and a few other tags
                .replace( /&lt;(!|script[^&gt;]*&gt;.*?&lt;\/script(?=[&gt;\s])|\/?(\?xml(:\w+)?|xml|meta|link|style|\w+:\w+)(?=[\s\/&gt;]))[^&gt;]*&gt;/gi, &quot;&quot; )
                //convert word headers to strong
                .replace( /&lt;p [^&gt;]*class=&quot;?MsoHeading&quot;?[^&gt;]*&gt;(.*?)&lt;\/p&gt;/gi, &quot;&lt;p&gt;&lt;strong&gt;$1&lt;/strong&gt;&lt;/p&gt;&quot; )
                //remove lang attribute
                .replace( /(lang)\s*=\s*([\'\&quot;]?)[\w-]+\2/ig, &quot;&quot; )
                //清除多余的font不能匹配&amp;nbsp;有可能是空格
                .replace( /&lt;font[^&gt;]*&gt;\s*&lt;\/font&gt;/gi, '' )
                //清除多余的class
                .replace( /class\s*=\s*[&quot;']?(?:(?:MsoTableGrid)|(?:MsoNormal(Table)?))\s*[&quot;']?/gi, '' );

            // Examine all styles: delete junk, transform some, and keep the rest
            //修复了原有的问题, 比如style='fontsize:&quot;宋体&quot;'原来的匹配失效了
            str = str.replace( /(&lt;[a-z][^&gt;]*)\sstyle=([&quot;'])([^\2]*?)\2/gi, function( str, tag, tmp, style ) {

                var n = [],
                        i = 0,
                        s = style.replace( /^\s+|\s+$/, '' ).replace( /&amp;quot;/gi, &quot;'&quot; ).split( /;\s*/g );

                // Examine each style definition within the tag's style attribute
                for ( var i = 0; i &lt; s.length; i++ ) {
                    var v = s[i];
                    var name, value,
                            parts = v.split( &quot;:&quot; );

                    if ( parts.length == 2 ) {
                        name = parts[0].toLowerCase();
                        value = parts[1].toLowerCase();
                        // Translate certain MS Office styles into their CSS equivalents
                        switch ( name ) {
                            case &quot;mso-padding-alt&quot;:
                            case &quot;mso-padding-top-alt&quot;:
                            case &quot;mso-padding-right-alt&quot;:
                            case &quot;mso-padding-bottom-alt&quot;:
                            case &quot;mso-padding-left-alt&quot;:
                            case &quot;mso-margin-alt&quot;:
                            case &quot;mso-margin-top-alt&quot;:
                            case &quot;mso-margin-right-alt&quot;:
                            case &quot;mso-margin-bottom-alt&quot;:
                            case &quot;mso-margin-left-alt&quot;:
                            case &quot;mso-table-layout-alt&quot;:
                            case &quot;mso-height&quot;:
                            case &quot;mso-width&quot;:
                            case &quot;mso-vertical-align-alt&quot;:
                                //trace:1819 ff下会解析出padding在table上
                                if(!/&lt;table/.test(tag))
                                    n[i] = name.replace( /^mso-|-alt$/g, &quot;&quot; ) + &quot;:&quot; + ensureUnits( value );
                                continue;
                            case &quot;horiz-align&quot;:
                                n[i] = &quot;text-align:&quot; + value;
                                continue;

                            case &quot;vert-align&quot;:
                                n[i] = &quot;vertical-align:&quot; + value;
                                continue;

                            case &quot;font-color&quot;:
                            case &quot;mso-foreground&quot;:
                                n[i] = &quot;color:&quot; + value;
                                continue;

                            case &quot;mso-background&quot;:
                            case &quot;mso-highlight&quot;:
                                n[i] = &quot;background:&quot; + value;
                                continue;

                            case &quot;mso-default-height&quot;:
                                n[i] = &quot;min-height:&quot; + ensureUnits( value );
                                continue;

                            case &quot;mso-default-width&quot;:
                                n[i] = &quot;min-width:&quot; + ensureUnits( value );
                                continue;

                            case &quot;mso-padding-between-alt&quot;:
                                n[i] = &quot;border-collapse:separate;border-spacing:&quot; + ensureUnits( value );
                                continue;

                            case &quot;text-line-through&quot;:
                                if ( (value == &quot;single&quot;) || (value == &quot;double&quot;) ) {
                                    n[i] = &quot;text-decoration:line-through&quot;;
                                }
                                continue;


                            //trace:1870
//                            //word里边的字体统一干掉
//                            case 'font-family':
//                                continue;
                            case &quot;mso-zero-height&quot;:
                                if ( value == &quot;yes&quot; ) {
                                    n[i] = &quot;display:none&quot;;
                                }
                                continue;
                            case 'margin':
                                if ( !/[1-9]/.test( parts[1] ) ) {
                                    continue;
                                }
                        }

                        if ( /^(mso|column|font-emph|lang|layout|line-break|list-image|nav|panose|punct|row|ruby|sep|size|src|tab-|table-border|text-(?:decor|trans)|top-bar|version|vnd|word-break)/.test( name ) ) {
                            if ( !/mso\-list/.test( name ) )
                                continue;
                        }
                        n[i] = name + &quot;:&quot; + parts[1];        // Lower-case name, but keep value case
                    }
                }
                // If style attribute contained any valid styles the re-write it; otherwise delete style attribute.
                if ( i &gt; 0 ) {
                    return tag + ' style=&quot;' + n.join( ';' ) + '&quot;';
                } else {
                    return tag;
                }
            } );
            str = str.replace( /([ ]+)&lt;\/span&gt;/ig, function ( m, p ) {
                return new Array( p.length + 1 ).join( '&amp;nbsp;' ) + '&lt;/span&gt;';
            } );
            return str;
        }

        return function ( html ) {

            //过了word,才能转p-&gt;li
            first = null;
            parentTag = '',liStyle = '',firstTag = '';
            if ( isWordDocument( html ) ) {
                html = filterPasteWord( html );
            }
            return html.replace( /&gt;[ \t\r\n]*&lt;/g, '&gt;&lt;' );
        };
    }();
    var NODE_NAME_MAP = {
        'text': '#text',
        'comment': '#comment',
        'cdata': '#cdata-section',
        'fragment': '#document-fragment'
    };

    function _likeLi( node ) {
        var a;
        if ( node &amp;&amp; node.tag == 'p' ) {
            //office 2011下有效
            if ( node.attributes['class'] == 'MsoListParagraph' || /mso-list/.test( node.attributes.style ) ) {
                a = 1;
            } else {
                var firstChild = node.children[0];
                if ( firstChild &amp;&amp; firstChild.tag == 'span' &amp;&amp; /Wingdings/i.test( firstChild.attributes.style ) ) {
                    a = 1;
                }
            }
        }
        return a;
    }

    //为p==&gt;li 做个标志
    var first,
            orderStyle = {
                'decimal' : /\d+/,
                'lower-roman': /^m{0,4}(cm|cd|d?c{0,3})(xc|xl|l?x{0,3})(ix|iv|v?i{0,3})$/,
                'upper-roman': /^M{0,4}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})$/,
                'lower-alpha' : /^\(?[a-z]+\)?$/,
                'upper-alpha': /^\(?[A-Z]+\)?$/
            },
            unorderStyle = { 'disc' : /^[l\u00B7\u2002]/, 'circle' : /^[\u006F\u00D8]/,'square' : /^[\u006E\u25C6]/},
            parentTag = '',liStyle = '',firstTag;


    //写入编辑器时，调用，进行转换操作
    function transNode( node, word_img_flag ) {
        //dtd.$removeEmptyBlock[node.tag]
        if ( node.type == 'element' &amp;&amp; !node.children.length &amp;&amp; (dtd.$removeEmpty[node.tag]) &amp;&amp; node.tag != 'a' ) {// 锚点保留


            return {
                type : 'fragment',
                children:[]
            }
        }
        var sizeMap = [0, 10, 12, 16, 18, 24, 32, 48],
                attr,
                indexOf = utils.indexOf;

        switch ( node.tag ) {
            case 'img':
                //todo base64暂时去掉，后边做远程图片上传后，干掉这个
                if(node.attributes.src &amp;&amp; /^data:/.test(node.attributes.src)){
                    return {
                        type : 'fragment',
                        children:[]
                    }
                }
                if ( node.attributes.src &amp;&amp; /^(?:file)/.test( node.attributes.src ) ) {
                    if ( !/(gif|bmp|png|jpg|jpeg)$/.test( node.attributes.src ) ) {
                        return {
                            type : 'fragment',
                            children:[]
                        }
                    }
                    node.attributes.word_img = node.attributes.src;
                    node.attributes.src = me.options.UEDITOR_HOME_URL + 'themes/default/images/spacer.gif';
                    var flag = parseInt(node.attributes.width)&lt;128||parseInt(node.attributes.height)&lt;43;
                    node.attributes.style=&quot;background:url(&quot; + me.options.UEDITOR_HOME_URL +&quot;themes/default/images/&quot;+(flag?&quot;word.gif&quot;:&quot;localimage.png&quot;)+&quot;) no-repeat center center;border:1px solid #ddd&quot;;
                    //node.attributes.style = 'width:395px;height:173px;';
                    word_img_flag &amp;&amp; (word_img_flag.flag = 1);
                }
                if(browser.ie &amp;&amp; browser.version &lt; 7 &amp;&amp; me.options.relativePath)
                    node.attributes.orgSrc = node.attributes.src;
                node.attributes.data_ue_src = node.attributes.data_ue_src || node.attributes.src;
                break;
            case 'li':
                var child = node.children[0];

                if ( !child || child.type != 'element' || child.tag != 'p' &amp;&amp; dtd.p[child.tag] ) {
                    var tmpPNode = {
                        type: 'element',
                        tag: 'p',
                        attributes: {},

                        parent : node
                    };
                    tmpPNode.children = child ? node.children :[
                            browser.ie ? {
                                type:'text',
                                data:domUtils.fillChar,
                                parent : tmpPNode

                            }:
                            {
                                type : 'element',
                                tag : 'br',
                                attributes:{},
                                closed: true,
                                children: [],
                                parent : tmpPNode
                            }
                    ];
                    node.children =   [tmpPNode];
                }
                break;
            case 'table':
            case 'td':
                optStyle( node );
                break;
            case 'a'://锚点，a==&gt;img
                if ( node.attributes['anchorname'] ) {
                    node.tag = 'img';
                    node.attributes = {
                        'class' : 'anchorclass',
                        'anchorname':node.attributes['name']
                    };
                    node.closed = 1;
                }
                node.attributes.href &amp;&amp; (node.attributes.data_ue_src = node.attributes.href);
                break;
            case 'b':
                node.tag = node.name = 'strong';
                break;
            case 'i':
                node.tag = node.name = 'em';
                break;
            case 'u':
                node.tag = node.name = 'span';
                node.attributes.style = (node.attributes.style || '') + ';text-decoration:underline;';
                break;
            case 's':
            case 'del':
                node.tag = node.name = 'span';
                node.attributes.style = (node.attributes.style || '') + ';text-decoration:line-through;';
                if ( node.children.length == 1 ) {
                    child = node.children[0];
                    if ( child.tag == node.tag ) {
                        node.attributes.style += &quot;;&quot; + child.attributes.style;
                        node.children = child.children;

                    }
                }
                break;
            case 'span':
                if ( /mso-list/.test( node.attributes.style ) ) {
                    

                    //判断了两次就不在判断了
                    if ( firstTag != 'end' ) {

                        var ci = node.children[0],p;
                        while ( ci.type == 'element' ) {
                            ci = ci.children[0];
                        }
                        for ( p in unorderStyle ) {
                            if ( unorderStyle[p].test( ci.data ) ) {
                                
                                // ci.data = ci.data.replace(unorderStyle[p],'');
                                parentTag = 'ul';
                                liStyle = p;
                                break;
                            }
                        }


                        if ( !parentTag ) {
                            for ( p in orderStyle ) {
                                if ( orderStyle[p].test( ci.data.replace( /\.$/, '' ) ) ) {
                                    //   ci.data = ci.data.replace(orderStyle[p],'');
                                    parentTag = 'ol';
                                    liStyle = p;
                                    break;
                                }
                            }
                        }
                        if ( firstTag ) {
                            if ( ci.data == firstTag ) {
                                if ( parentTag != 'ul' ) {
                                    liStyle = '';
                                }
                                parentTag = 'ul'
                            } else {
                                if ( parentTag != 'ol' ) {
                                    liStyle = '';
                                }
                                parentTag = 'ol'
                            }
                            firstTag = 'end'
                        } else {
                            firstTag = ci.data
                        }
                        if ( parentTag ) {
                            var tmpNode = node;
                            while ( tmpNode &amp;&amp; tmpNode.tag != 'ul' &amp;&amp; tmpNode.tag != 'ol' ) {
                                tmpNode = tmpNode.parent;
                            }
                            if(tmpNode ){
                                  tmpNode.tag = parentTag;
                                tmpNode.attributes.style = 'list-style-type:' + liStyle;
                            }



                        }

                    }

                    node = {
                        type : 'fragment',
                        children : []
                    };
                    break;


                }
                var style = node.attributes.style;
                if ( style ) {
                    //trace:1493
                    //ff3.6出来的是background: none repeat scroll %0 %0 颜色
                    style = style.match( /(?:\b(?:color|font-size|background(-color)?|font-family|text-decoration)\b\s*:\s*(&amp;[^;]+;|[^;])+(?=;)?)/gi );
                    if ( style ) {
                        node.attributes.style = style.join( ';' );
                        if ( !node.attributes.style ) {
                            delete node.attributes.style;
                        }
                    }
                }

                //针对ff3.6span的样式不能正确继承的修复
                
                if(browser.gecko &amp;&amp; browser.version &lt;= 10902 &amp;&amp; node.parent){
                    var parent = node.parent;
                    if(parent.tag == 'span' &amp;&amp; parent.attributes &amp;&amp; parent.attributes.style){
                        node.attributes.style = parent.attributes.style + ';' + node.attributes.style;
                    }
                }
                if ( utils.isEmptyObject( node.attributes ) ) {
                    node.type = 'fragment'
                }
                break;
            case 'font':
                node.tag = node.name = 'span';
                attr = node.attributes;
                node.attributes = {
                    'style': (attr.size ? 'font-size:' + (sizeMap[attr.size] || 12) + 'px' : '')
                    + ';' + (attr.color ? 'color:'+ attr.color : '')
                    + ';' + (attr.face ? 'font-family:'+ attr.face : '')
                    + ';' + (attr.style||'')
                };

                while(node.parent.tag == node.tag &amp;&amp; node.parent.children.length == 1){
                    node.attributes.style &amp;&amp; (node.parent.attributes.style ? (node.parent.attributes.style += &quot;;&quot; + node.attributes.style) : (node.parent.attributes.style = node.attributes.style));
                    node.parent.children = node.children;
                    node = node.parent;

                }
                break;
            case 'p':
                if ( node.attributes.align ) {
                    node.attributes.style = (node.attributes.style || '') + ';text-align:' +
                            node.attributes.align + ';';
                    delete node.attributes.align;
                }

                if ( _likeLi( node ) ) {

                    if ( !first ) {

                        var ulNode = {
                            type: 'element',
                            tag: 'ul',
                            attributes: {},
                            children: []
                        },
                                index = indexOf( node.parent.children, node );
                        node.parent.children[index] = ulNode;
                        ulNode.parent = node.parent;
                        ulNode.children[0] = node;
                        node.parent = ulNode;

                        while ( 1 ) {
                            node = ulNode.parent.children[index + 1];
                            if ( _likeLi( node ) ) {
                                ulNode.children[ulNode.children.length] = node;
                                node.parent = ulNode;
                                ulNode.parent.children.splice( index + 1, 1 );

                            } else {
                                break;
                            }
                        }

                        return ulNode;
                    }
                    node.tag = node.name = 'li';
                    //为chrome能找到标号做的处理
                    if ( browser.webkit ) {
                        var span = node.children[0];

                        while ( span &amp;&amp; span.type == 'element' ) {
                            span = span.children[0]
                        }
                        span &amp;&amp; (span.parent.attributes.style = (span.parent.attributes.style || '') + ';mso-list:10');
                    }


                    delete node.attributes['class'];
                    delete node.attributes.style;


                }
        }
        return node;
    }

    function optStyle( node ) {
        if ( ie &amp;&amp; node.attributes.style ) {
            var style = node.attributes.style;
            node.attributes.style = style.replace(/;\s*/g,';');
            node.attributes.style = node.attributes.style.replace( /^\s*|\s*$/, '' )
        }
    }

    function transOutNode( node ) {
        switch ( node.tag ) {
            case 'table':
                !node.attributes.style &amp;&amp; delete node.attributes.style;
                if ( ie &amp;&amp; node.attributes.style ) {

                    optStyle( node );
                }
                break;
            case 'td':
            case 'th':
                if ( /display\s*:\s*none/i.test( node.attributes.style ) ) {
                    return {
                        type: 'fragment',
                        children: []
                    };
                }
                if ( ie &amp;&amp; !node.children.length ) {
                    var txtNode = {
                        type: 'text',
                        data:domUtils.fillChar,
                        parent : node
                    };
                    node.children[0] = txtNode;
                }
                if ( ie &amp;&amp; node.attributes.style ) {
                    optStyle( node );

                }
                break;
            case 'img'://锚点，img==&gt;a
                if ( node.attributes.anchorname ) {
                    node.tag = 'a';
                    node.attributes = {
                        name : node.attributes.anchorname,
                        anchorname : 1
                    };
                    node.closed = null;
                }else{
                    if(node.attributes.data_ue_src){
                        node.attributes.src = node.attributes.data_ue_src;
                        delete node.attributes.data_ue_src;
                    }
                }
                break;

            case 'a':
                if(node.attributes.data_ue_src){
                    node.attributes.href = node.attributes.data_ue_src;
                    delete node.attributes.data_ue_src;
                }
        }

        return node;
    }

    function childrenAccept( node, visit, ctx ) {

        if ( !node.children || !node.children.length ) {
            return node;
        }
        var children = node.children;
        for ( var i = 0; i &lt; children.length; i++ ) {
            var newNode = visit( children[i], ctx );
            if ( newNode.type == 'fragment' ) {
                var args = [i, 1];
                args.push.apply( args, newNode.children );
                children.splice.apply( children, args );
                //节点为空的就干掉，不然后边的补全操作会添加多余的节点
                if ( !children.length ) {
                    node = {
                        type: 'fragment',
                        children: []
                    }
                }
                i --;
            } else {
                children[i] = newNode;
            }
        }
        return node;
    }

    function Serialize( rules ) {
        this.rules = rules;
    }

    Serialize.prototype = {
        // NOTE: selector目前只支持tagName
        rules: null,
        // NOTE: node必须是fragment
        filter: function ( node, rules, modify ) {
            rules = rules || this.rules;
            var whiteList = rules &amp;&amp; rules.whiteList;
            var blackList = rules &amp;&amp; rules.blackList;

            function visitNode( node, parent ) {
                node.name = node.type == 'element' ?
                        node.tag : NODE_NAME_MAP[node.type];
                if ( parent == null ) {
                    return childrenAccept( node, visitNode, node );
                }

                if ( blackList &amp;&amp; blackList[node.name] ) {
                    modify &amp;&amp; (modify.flag = 1);
                    return {
                        type: 'fragment',
                        children: []
                    };
                }
                if ( whiteList ) {
                    if ( node.type == 'element' ) {
                        if ( parent.type == 'fragment' ? whiteList[node.name] : whiteList[node.name] &amp;&amp; whiteList[parent.name][node.name] ) {

                            var props;
                            if ( (props = whiteList[node.name].$) ) {
                                var oldAttrs = node.attributes;
                                var newAttrs = {};
                                for ( var k in props ) {
                                    if ( oldAttrs[k] ) {
                                        newAttrs[k] = oldAttrs[k];
                                    }
                                }
                                node.attributes = newAttrs;
                            }


                        } else {
                            modify &amp;&amp; (modify.flag = 1);
                            node.type = 'fragment';
                            // NOTE: 这里算是一个hack
                            node.name = parent.name;
                        }
                    } else {
                        // NOTE: 文本默认允许
                    }
                }
                if ( blackList || whiteList ) {
                    childrenAccept( node, visitNode, node );
                }
                return node;
            }

            return visitNode( node, null );
        },
        transformInput: function ( node, word_img_flag ) {

            function visitNode( node ) {
                node = transNode( node, word_img_flag );
                if ( node.tag == 'ol' || node.tag == 'ul' ) {
                    first = 1;
                }
                node = childrenAccept( node, visitNode, node );
                if ( node.tag == 'ol' || node.tag == 'ul' ) {
                    first = 0;
                    parentTag = '',liStyle = '',firstTag = '';
                }
                if ( node.type == 'text' &amp;&amp; node.data.replace( /\s/g, '' ) == me.options.pageBreakTag ) {

                    node.type = 'element';
                    node.name = node.tag = 'hr';

                    delete node.data;
                    node.attributes = {
                        'class' : 'pagebreak',
                        noshade:&quot;noshade&quot;,
                        size:&quot;5&quot;,
                        'unselectable' : 'on',
                        'style' : 'moz-user-select:none;-khtml-user-select: none;'
                    };

                    node.children = [];

                }
                //去掉多余的空格和换行
                if(node.type == 'text' &amp;&amp; !dtd.$notTransContent[node.parent.tag]){
                    node.data = node.data.replace(/[\r\t\n]*/g,'')//.replace(/[ ]*$/g,'')
                }
                return node;
            }

            return visitNode( node );
        },
        transformOutput: function ( node ) {
            function visitNode( node ) {

                if ( node.tag == 'hr' &amp;&amp; node.attributes['class'] == 'pagebreak' ) {
                    delete node.tag;
                    node.type = 'text';
                    node.data = me.options.pageBreakTag;
                    delete node.children;

                }

                node = transOutNode( node );
                if ( node.tag == 'ol' || node.tag == 'ul' ) {
                    first = 1;
                }
                node = childrenAccept( node, visitNode, node );
                if ( node.tag == 'ol' || node.tag == 'ul' ) {
                    first = 0;
                }
                return node;
            }

            return visitNode( node );
        },
        toHTML: toHTML,
        parseHTML: parseHTML,
        word: transformWordHtml
    };
    me.serialize = new Serialize( me.options.serialize );
    UE.serialize = new Serialize( {} );
};
</pre>
</body>
</html>
